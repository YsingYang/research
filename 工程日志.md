## 2017. 6. 6

### 突然想加个工程日志的原因
我忘了昨天想写什么来着了, 很烦..

### 记录
基本完成beacon帧的伪造转发, 不过实验中发现一点比较奇怪的地方是, 在wireshark中观察到, RTS收到的概率大概是Beacon的10倍?(伪造的帧).
另外暂时不清楚中间有无Bug, 因为在beacon帧的伪造中需要对之中的ie域进行修改, 那么这就导致了,ssid的变化会使得后面的域都要相应的前移或者后移, 


## 2017. 6. 7

### 今天写啥好
把两个主动攻击捕获到的目标写完吧

### 改进, 看能不能给targetList特化一个unordered_map

### 问题
设计得有点问题, 感觉targetControl这个类有点费, 还有应该传入一个u_char的vector而不是char的. 明天先改下这两个地方


## 2017. 6. 8
### 跟进昨天内容
想了一下还是把targetControl这个类去掉了, 无意义的封装, 仅仅只是封装了一个vector, 直接将targetList的vector放到server中

### 设计一下被动跟踪的思路吧
增加device, deviceSet类, 但是设计还没有完全, 目前没有想到一种比较好的方法取设计匹配过程

## 2017. 6. 12
### z终于有空可以开始更新这个了..

### 理想目标
用capinfo + pksize作为一个key , 映射一个set<device>的集合, 每次收到一个随机地址, 匹配所属set的设备是否存在有信息匹配的设备

### 任务进展
1. 由于需要返回一个device的类, 但是deviceSet这个集合在server这个类中, 解析函数缺在packet中, 所以一种合理的方法是重新定义一种返回device集合的解析方法,解析完后将new 出来的device 返回给server中. 从而让server能将device加入到deviceSet中.	

### 任务进展
继续完成sptrParse()函数的编写

###2017. 6. 15
前天赶着刷题..昨天出去吃饭浪费了两个小时...于是两天没更新了..(其实就是懒 嗯.)

####任务进展
增加了相应的sptrParse的函数, 用于new 相应的device, 但在其中也发现了之前的一些错误

####问题
之前memcpymgmt body时候可能是有问题的, 因为mgmt的大小似乎是未知的, 不要是ie域是可变的, 所以beacon与probeRequest中会导致一些问题

###2017. 6. 16
####任务进展
今天对RTS进行实验发现, 对于离路由器十分接近的设备, 回复RTS的效率特别高, 当然有一段时间的空余间隔(不知道是否在切换信道所致), 发现在5米内CTS接收频率在1~5S的可接受范围内, 那么可以考虑蜂窝网络的布局

####问题
对于SSID的接收还有一部分的问题. 我觉得应该可能到时候要打印一下具体的内容, 来检查其中是不是内存new的大小


###2017. 6. 17
####任务
我觉得可以先把其中SSID的BUG找出来.
然后找了半个小时...终于找到了.., 忘记在frameLength长度那里减去固定长度...导致内存越界, 读到其奇奇怪怪的东西..难怪有时候SSID会为一堆乱码

###2017. 6. 24
捣鼓了几天路由器..不知道为啥不能间接ssh上同一网段下的路由器, 然后检查了一下发现..没装openssh..但是为什么如果路由器作为AP(.1.1), 就可以直接连上, 但是如果作为一个客户端(.1.xx)就连不上 .装了openssh后才连上, 好奇怪


###2017. 6. 25
搞了一个小时不知道为什么客户端路由不能发包发往服务器..结果是没有设置为monitor模式...

###2017. 6. 26
今天主要写了deviceSet的比较函数, 发现程序写多了, 确实是会写得比以前优雅很多的, 以前用了map->map->map, 现在用两个值成一个pair做为key值, 映射到一个自定义的compare的set, 这样, 虽然关系还是跟之前差不多.

不过为了写这个绕了许多弯路, 但也基本学会了, 两个不同自定义set的方法
1. 将set的元素与想要的key封装成一个新的struct , 成为新的set\< struct\>
2. 像侯捷老师说的泛函数一样写一个类继承, 同时自定义一个operator()方法, 我觉的第二种方法最实用也最简单
```
struct setCompare : public std::binary_function<std::shared_ptr<device>, std::shared_ptr<device>, bool>{
    bool operator()(const std::shared_ptr<device>& d1, const std::shared_ptr<device> &d2) const{
        return d1->getMACKey() < d2->getMACKey();
    }
}; //以MAC作为比较操作的set
```